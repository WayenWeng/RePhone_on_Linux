#include <stdio.h>
#include <fcntl.h>
#if defined(__GNUC__) /* GCC CS3 */
#include <sys/stat.h>
#endif

#include "vmtype.h"
#include "vmlog.h"
#include "vmmemory.h"
#include "vmdcl.h"
#include "vmdcl_gpio.h"
#include "vmdcl_pwm.h"
#include "vmfs.h"
#include "vmchset.h"
#include "vmdatetime.h"
#include "vmthread.h"
#include "vmboard.h"

#define LOG(args...) //printf(args)


typedef VMINT (*vm_get_sym_entry_t)(char* symbol);
vm_get_sym_entry_t vm_get_sym_entry;

#define RESERVED_HEAP 1024*64             // heap reserved for C usage

unsigned int g_memory_size = 1024 * 800;  // heap for lua usage, will be adjusted
int g_memory_size_b = 0;                  // adjusted heap for C usage
static void* g_base_address = NULL;       // base address of the lua heap

extern void vm_main();

int __g_errno = 0;


char *__tzname[2] = { (char *) "CET", (char *) "CET" };
int __daylight = 1;
long int __timezone = 1L;


//-----------------------
void __cxa_pure_virtual()
{
    while(1)
        ;
}

//------------
int* __errno()
{
    return &__g_errno;
}
/*
//----------------------------
extern caddr_t _sbrk(int incr)
{
    static void* heap = NULL;
    static void* base = NULL;
    void* prev_heap;

    if(heap == NULL) {
        base = (unsigned char*)g_base_address;
        if(base == NULL) {
            vm_log_fatal("malloc failed");
        } else {
            heap = base;
            vm_log_info("Init memory success, base: %#08x, size: %d, heap: %d", (caddr_t)g_base_address, g_memory_size, g_memory_size_b);
        }
    }

    prev_heap = heap;

    if(heap + incr > g_base_address + g_memory_size) {
        vm_log_fatal("Not enough memory");
    }
    else {
    	heap += incr;
    }

    return (caddr_t)prev_heap;
}

//---------------------------------------------
extern int link(char* old_name, char* new_name)
{
    VMWCHAR ucs_oldname[32], ucs_newname[32];
    vm_chset_ascii_to_ucs2(ucs_oldname, 32, old_name);
    vm_chset_ascii_to_ucs2(ucs_newname, 32, new_name);
    //return vm_fs_rename(old_name, new_name);
    return vm_fs_rename(ucs_oldname, ucs_newname);
}

//----------------------------------------------
int _open(const char* file, int flags, int mode)
{
    int result;
    VMUINT fs_mode;
    VMWCHAR wfile_name[64];
    char file_name[64];
    char* ptr;

    if(file[1] != ':') {
        snprintf(file_name, sizeof(file_name), "C:\\%s", file);
        ptr = file_name;
    } else {
        ptr = (char *)file;
    }

    vm_chset_ascii_to_ucs2(wfile_name, 64, ptr);

    if(flags & O_CREAT) {
        fs_mode = VM_FS_MODE_CREATE_ALWAYS_WRITE;
    } else if((flags & O_RDWR) || (flags & O_WRONLY)) {
        fs_mode = VM_FS_MODE_WRITE;
    } else {
        fs_mode = VM_FS_MODE_READ;
    }

    if(flags & O_APPEND) {
        fs_mode |= VM_FS_MODE_APPEND;
    }

    result = vm_fs_open(wfile_name, fs_mode, 0);
    LOG("_open(%s, 0x%X, 0x%X) - %d\n", file, flags, mode, result);
    return result;
}

//-------------------------
extern int _close(int file)
{
    LOG("_close(%d)\n", file);
    vm_fs_close(file);
    return 0;
}

//------------------------------------------
extern int _fstat(int file, struct stat* st)
{
    int size;
    st->st_mode = S_IFCHR;

    if(file < 3) {
        return 0;
    }

    if(vm_fs_get_size(file, &size) > 0) {
        st->st_size = size;
    }

    LOG("_fstat(%d, 0x%X) - size: %d\n", file, (int)st, size);
    return 0;
}

//--------------------------
extern int _isatty(int file)
{
    if(file < 3) {
        return 1;
    }

    LOG("_isatty(%d)\n", file);
    return 0;
}

//-------------------------------------------------
extern int _lseek(int file, int offset, int whence)
{
    int position;
    int result;

    vm_fs_seek(file, offset, whence + 1);
    result = vm_fs_get_position(file, &position);

    LOG("_lseek(%d, %d, %d) - %d\n", file, offset, whence, position);
    return position;
}

//---------------------------------------
__attribute__((weak)) int retarget_getc()
{
    return 0;
}

//--------------------------------------------
extern int _read(int file, char* ptr, int len)
{
    if(file < 3) {
        int i;
        for(i = 0; i < len; i++) {
            *ptr = retarget_getc();
            ptr++;
        }
        return len;
    } else {
        int read_bytes = len;
        int bytes;
        bytes = vm_fs_read(file, ptr, len, &read_bytes);
        LOG("_read(%d, %s, %d, %d) - %d\n", file, ptr, len, read_bytes, bytes);
        return bytes;
    }
}

//----------------------------------------------
__attribute__((weak)) void retarget_putc(char c)
{
}

//---------------------------------------------
extern int _write(int file, char* ptr, int len)
{
    if(file < 3) {
        int i;

        for(i = 0; i < len; i++) {
            retarget_putc(*ptr);
            ptr++;
        }
        return len;
    } else {
        VMUINT written_bytes;

        vm_fs_write(file, ptr, len, &written_bytes);
        LOG("_write(%d, %s, %d, %d)\n", file, ptr, len, written_bytes);
        return written_bytes;
    }
}

//---------------------------
extern void _exit(int status)
{
    for(;;)
        ;
}

//---------------------------------
extern void _kill(int pid, int sig)
{
    return;
}

//----------------------
extern int _getpid(void)
{
    return -1;
}

//-----------------------------
int __cxa_guard_acquire(int* g)
{
    return !*(char*)(g);
};

//------------------------------
void __cxa_guard_release(int* g)
{
    *(char*)g = 1;
};
*/
typedef void (**__init_array)(void);

//void __libc_init_array(void);

//-----------------------------------------------------------------------------------
void gcc_entry(unsigned int entry, unsigned int init_array_start, unsigned int count)
{
    unsigned int i;
    void* g_base_address_b = NULL;

    __init_array ptr;
    vm_get_sym_entry = (vm_get_sym_entry_t)entry;

    while (g_base_address == NULL) {
    	g_base_address = vm_malloc(g_memory_size);
        if (g_base_address == NULL) {
        	g_memory_size -= 1024;
        }
        else break;
    }
    vm_free(g_base_address);
    g_base_address = NULL;
    g_memory_size_b = RESERVED_HEAP;
    g_memory_size -= RESERVED_HEAP;
	g_base_address = vm_malloc(g_memory_size);

    while ((g_base_address_b == NULL) && (g_memory_size_b > 0)) {
    	g_base_address_b = vm_malloc(g_memory_size_b);
        if (g_base_address_b == NULL) {
        	g_memory_size_b -= 1024;
        }
        else break;
    }
    if (g_memory_size_b < 0) g_memory_size_b = 0;
    if (g_base_address_b != NULL) vm_free(g_base_address_b);
    g_base_address_b = NULL;

    ptr = (__init_array)init_array_start;
    for(i = 1; i < count; i++) {
        ptr[i]();
    }

    /*while (vm_time_ust_get_count() < 10000000) {
    	vm_thread_sleep(10);
    }*/
    vm_main();
}

